package org.dka.coingame.coins

import cats.syntax.all.*
import org.dka.coingame
import org.dka.coingame.Seed
import org.dka.coingame.coins._
import org.scalatest.funspec.AnyFunSpec
import org.scalatest.matchers.should.Matchers.*

class CoinTossHistorySpec extends AnyFunSpec {
  describe("AlwaysHeadsUp") {
    it ("should always be heads up") {
      val lastState = tossCoins(100, Coin.HeadsUp)(AlwaysHeadsUpTossHistory.next)
      lastState.history.contains(Coin.TailsUp) shouldBe false
    }
  }
//  describe("AlwaysTailsUp") {
//    it ("should always be tails up") {
//      val results: List[Coin] = (1 to 100).toList.map(i => {
//        AlwaysTailsUpTossHistory.nextCoin(Seed(i), Coin.HeadsUp)._2
//      })
//      results.contains(Coin.HeadsUp) shouldBe false
//    }
//  }
//  describe("MostlyHeads") {
//    val tossCount = 100
//    val ratio = 5
//    val tosser = MostlyHeadsCoinTossHistory(ratio)
//    it ("should mostly be tails up") {
//       start at 2 because we already have the first one (the initial)
//      val state: CoinStateHistory = (2 to tossCount).toList
//        .foldLeft( CoinStateHistory.initial(Coin.HeadsUp)) ( (state, i) => {
//          val (nextSeed, coin) = tosser.nextCoin(Seed(i), state.value)
//          state.update(coin)
//      })
//      val headsCount = state.history.filter(_ == Coin.HeadsUp).size
//      val tailsCount = state.history.filter(_ == Coin.TailsUp).size
//      state.history.reverse.head shouldBe Coin.HeadsUp
//      headsCount should be > tailsCount
//      tailsCount shouldBe tossCount/ratio
//    }
//  }
//  describe("MostlyTails") {
//    val tossCount = 100
//    val ratio = 4
//    val tosser = MostlyTailsCoinTossHistory(ratio)
//    it ("should mostly be tails up") {
//       start at 2 because we already have the first one (the initial)
//      val state: CoinStateHistory = (2 to tossCount).toList
//        .foldLeft( CoinStateHistory.initial(Coin.TailsUp)) ( (state, i) => {
//          val (nextSeed, coin) = tosser.nextCoin(Seed(i), state.value)
//          state.update(coin)
//        })
      // skip the initial since it is not part of the generation of the history
//      val headsCount = state.history.filter(_ == Coin.HeadsUp).size
//      val tailsCount = state.history.filter(_ == Coin.TailsUp).size
//      state.history.size shouldBe tossCount
//      state.history.reverse.head shouldBe Coin.TailsUp
//      tailsCount should be > headsCount
//      headsCount shouldBe 100/ratio
//    }
//  }
//  describe("RandomToss") {
//    val tossCount = 100
//    val tosser = RandomCoinTossHistory
//    it ("should mostly be random") {
//       start at 2 because we already have the first one (the initial)
//      val initial = (Seed(1), CoinStateHistory.initial(Coin.TailsUp))
//      val state: CoinStateHistory = (2 to tossCount).toList
//        .foldLeft( initial) ( (acc, i) => {
//          val (nextSeed, coin) = tosser.nextCoin(acc._1, acc._2.value)
//          val state = acc._2.update(coin)
//          (nextSeed, acc._2.update(coin))
//        })._2
      // skip the initial since it is not part of the generation of the history
//      val headsCount = state.history.filter(_ == Coin.HeadsUp).size
//      val tailsCount = state.history.filter(_ == Coin.TailsUp).size
//      state.history.size shouldBe tossCount
//      state.history.head shouldBe Coin.TailsUp
//    }
//    it ("should return the same newValue when using the same seed") {
      // start at 2 because we already have the first one (the initial)
//      val seed = Seed(15)
//      val coinFromSeed = tosser.nextCoin(seed, Coin.TailsUp)._2
//      println(s"coinFromSeed: $coinFromSeed")
//      val initial = (seed, CoinStateHistory.initial(coinFromSeed) ) // will have whatever is generated by seed
//      val state: CoinStateHistory = (2 to tossCount).toList
//        .foldLeft( initial) ( (acc, i) => {
//          val (_, coin) = tosser.nextCoin(seed, acc._2.value)
//          val state = acc._2.update(coin)
//          (seed, acc._2.update(coin)) // always use the same seed
//        })._2
//      state.history.contains(coinFromSeed.flipSide) shouldBe false
//
//    }
//  }

  private def tossCoins(count: Int, coin: Coin)
                       (next: CoinHistoryCriteria => (CoinHistoryCriteria, CoinHistory)): CoinHistory =
    val previous = CoinHistory.initial(coin)
    (1 to count).toList
      .foldLeft(previous) ( (history, i) => {
        val criteria = CoinHistoryCriteria(Seed(i), previous )
        next(criteria)._2
      })
}
